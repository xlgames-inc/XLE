// Copyright 2015 XLGAMES Inc.
//
// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#include "InterfaceSignature.h"
#include "AntlrHelper.h"
#include "Grammar/ShaderLexer.h"
#include "Grammar/ShaderParser.h"
#include "Grammar/ShaderTreeWalk.h"
#include "../Utility/StringUtils.h"
#include "../Utility/StringFormat.h"
#include "../Utility/Streams/Stream.h"
#include <assert.h>
#include <vector>

struct SSPFormalArg 
{ 
	StringId _name, _type, _semantic;
	unsigned _directionFlags;
};

struct SSPFunction
{
	StringId _name, _returnType, _returnSemantic;
	unsigned _firstArg, _lastArg;
	unsigned _hasImplementation;
};

struct SSPParameterStruct
{
	StringId _name;
	VariableId _firstParameter, _lastParameter;
};

namespace ShaderSourceParser
{
	class WorkingInterfaceStructure
	{
	public:
		ShaderFragmentSignature _signature;

		std::vector<std::pair<uint64_t, StringId>> _stringTableToId;
		std::vector<std::string> _stringTable;
		std::vector<FunctionSignature::Parameter> _parameterTable;
		std::vector<ParameterStructSignature::Parameter> _variableTable;

		std::string GetString(StringId id) const { return id != ~0u ? _stringTable[id] : std::string(); }
	};

	static pANTLR3_BASE_TREE BuildAST(struct ShaderParser_Ctx_struct& parser)
    {
		using namespace AntlrHelper;
        ExceptionContext exceptionContext;
        auto result = parser.entrypoint(&parser).tree;
        if (!exceptionContext._exceptions._errors.empty())
            Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		return result;
    }

    ShaderFragmentSignature BuildShaderFragmentSignature(StringSection<char> sourceCode)
    {
		using namespace AntlrHelper;
        AntlrPtr<struct ANTLR3_INPUT_STREAM_struct>	inputStream = antlr3StringStreamNew(
            (ANTLR3_UINT8*)sourceCode.begin(), ANTLR3_ENC_8BIT, 
            (unsigned)sourceCode.size(), (ANTLR3_UINT8*)"InputStream");

        if (!inputStream) Throw(::Exceptions::BasicLabel("Unable to create the input stream due to malloc() failure\n"));
		AntlrPtr<struct ShaderLexer_Ctx_struct> lxr = ShaderLexerNew(inputStream);	    // CLexerNew is generated by ANTLR
		if (!lxr) Throw(::Exceptions::BasicLabel("Unable to create the lexer due to malloc() failure\n"));

		AntlrPtr<struct ANTLR3_COMMON_TOKEN_STREAM_struct> tokenStream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
		if (!tokenStream) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate token stream\n"));
		AntlrPtr<struct ShaderParser_Ctx_struct> psr = ShaderParserNew(tokenStream);  // CParserNew is generated by ANTLR3
		if (!psr) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate parser\n"));

		auto* ast = BuildAST(*psr);
		if (!ast) Throw(::Exceptions::BasicLabel("Could not build AST from shader fragment input"));

		auto* strTree = ast->toStringTree(ast);

		AntlrPtr<struct ANTLR3_COMMON_TREE_NODE_STREAM_struct> nodes = antlr3CommonTreeNodeStreamNewTree(ast, ANTLR3_SIZE_HINT);
		AntlrPtr<struct ShaderTreeWalk_Ctx_struct> evalTree = ShaderTreeWalkNew(nodes);

		ExceptionContext exceptionContext;
		WorkingInterfaceStructure sig;
		evalTree->_userData = &sig;
		evalTree->entrypoint(evalTree);
		if (!exceptionContext._exceptions._errors.empty())
			Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		
		return sig._signature;
    }
}

extern "C" StringId String_Register(const void* ctx, const pANTLR3_BASE_TREE str) 
{
	auto* w = (ShaderSourceParser::WorkingInterfaceStructure*)((ShaderTreeWalk_Ctx_struct*)ctx)->_userData;
	auto s = ShaderSourceParser::AntlrHelper::AsString<char>(str->toString(str));
	auto h = Hash64(s);
	auto existing = LowerBound(w->_stringTableToId, h);
	if (existing != w->_stringTableToId.end() && existing->first == h) return existing->second;

	auto result = (StringId)w->_stringTable.size();
	w->_stringTable.push_back(s);
	w->_stringTableToId.insert(existing, {h, result});
	return result;
}

extern "C" FormalArgId FormalArg_Register(const void* ctx, struct SSPFormalArg arg)
{
	auto* w = (ShaderSourceParser::WorkingInterfaceStructure*)((ShaderTreeWalk_Ctx_struct*)ctx)->_userData;
	auto result = (StringId)w->_parameterTable.size();
	w->_parameterTable.push_back(
		ShaderSourceParser::FunctionSignature::Parameter{ w->GetString(arg._name), w->GetString(arg._type), w->GetString(arg._semantic), arg._directionFlags });
	return result;
}

extern "C" VariableId Variable_Register(const void* ctx, StringId name, StringId type, StringId semantic)
{
	auto* w = (ShaderSourceParser::WorkingInterfaceStructure*)((ShaderTreeWalk_Ctx_struct*)ctx)->_userData;
	auto result = (StringId)w->_variableTable.size();
	w->_variableTable.push_back(
		ShaderSourceParser::ParameterStructSignature::Parameter{ w->GetString(name), w->GetString(type), w->GetString(semantic) });
	return result;
}

extern "C" FunctionId Function_Register(const void* ctx, struct SSPFunction* func)
{
	auto* w = (ShaderSourceParser::WorkingInterfaceStructure*)((ShaderTreeWalk_Ctx_struct*)ctx)->_userData;
	ShaderSourceParser::FunctionSignature result;
	result._name = w->GetString(func->_name);
	result._returnType = w->GetString(func->_returnType);
	result._returnSemantic = w->GetString(func->_returnSemantic);
	for (unsigned p=func->_firstArg; p<=func->_lastArg; ++p)
		result._parameters.push_back(w->_parameterTable[p]);
	w->_signature._functions.emplace_back(std::move(result));
	return (FunctionId)(w->_signature._functions.size()-1);
}

extern "C" ParameterStructId ParameterStruct_Register(const void* ctx, struct SSPParameterStruct* paramStruct)
{
	auto* w = (ShaderSourceParser::WorkingInterfaceStructure*)((ShaderTreeWalk_Ctx_struct*)ctx)->_userData;
	ShaderSourceParser::ParameterStructSignature result;
	result._name = w->GetString(paramStruct->_name);
	for (unsigned p=paramStruct->_firstParameter; p<=paramStruct->_lastParameter; ++p)
		result._parameters.push_back(w->_variableTable[p]);
	w->_signature._parameterStructs.emplace_back(std::move(result));
	return (ParameterStructId)(w->_signature._parameterStructs.size()-1);
}
