// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#pragma warning(disable:4800) // 'int': forcing value to bool 'true' or 'false' (performance warning))

#include "GraphSyntax.h"
#include "ShaderPatcher.h"
#include "ShaderPatcher_Internal.h"
#include "SignatureProvider.h"
#include "AntlrHelper.h"
#include "Grammar/GraphSyntaxLexer.h"
#include "Grammar/GraphSyntaxParser.h"
#include "Grammar/GraphSyntaxEval.h"
#include "../Utility/FunctionUtils.h"
#include <unordered_map>
#include <stack>

#include <iostream>

typedef unsigned NodeId;
typedef unsigned ConnectorId;
typedef unsigned ConnectionId;
typedef unsigned GraphSignatureId;

typedef struct IdentifierAndScopeTag
{
	pANTLR3_COMMON_TOKEN _scope;
	pANTLR3_COMMON_TOKEN _identifier;
} IdentifierAndScope;

namespace ShaderPatcher
{
	using namespace ShaderSourceParser::AntlrHelper;

	class WorkingGraphSyntaxFile
	{
	public:
		class Graph
		{
		public:
			std::string 		_name;
			NodeGraph 			_graph;
			NodeGraphSignature 	_signature;

			struct Connector { uint32_t nodeId; std::string _name; };
			std::vector<Connector> _connectors;
			std::vector<std::string> _literalConnectors;
			std::unordered_map<std::string, uint32_t> _nodeNameMapping;
			std::unordered_map<std::string, std::pair<uint32_t, uint32_t>> _slotNameMapping;
		};

		std::vector<NodeGraphSignature> _pendingSignatures;

		using ActiveStack = std::stack<uint32_t>;
		std::unordered_map<unsigned, ActiveStack> _stacks;

		std::unordered_map<std::string, std::string> _imports; 
		std::vector<Graph> _graphs;
	};

	static pANTLR3_BASE_TREE BuildAST(struct GraphSyntaxParser_Ctx_struct& parser)
    {
        ExceptionContext exceptionContext;
        auto result = parser.entrypoint(&parser).tree;
        if (!exceptionContext._exceptions._errors.empty())
            Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		return result;
    }

    GraphSyntaxFile ParseGraphSyntax(StringSection<char> sourceCode)
    {
        AntlrPtr<struct ANTLR3_INPUT_STREAM_struct>	inputStream = antlr3StringStreamNew(
            (ANTLR3_UINT8*)sourceCode.begin(), ANTLR3_ENC_8BIT, 
            (unsigned)sourceCode.size(), (ANTLR3_UINT8*)"InputStream");

        if (!inputStream) Throw(::Exceptions::BasicLabel("Unable to create the input stream due to malloc() failure\n"));
		AntlrPtr<struct GraphSyntaxLexer_Ctx_struct> lxr = GraphSyntaxLexerNew(inputStream);	    // CLexerNew is generated by ANTLR
		if (!lxr) Throw(::Exceptions::BasicLabel("Unable to create the lexer due to malloc() failure\n"));

		AntlrPtr<struct ANTLR3_COMMON_TOKEN_STREAM_struct> tokenStream = antlr3CommonTokenStreamSourceNew(ANTLR3_SIZE_HINT, TOKENSOURCE(lxr));
		if (!tokenStream) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate token stream\n"));
		AntlrPtr<struct GraphSyntaxParser_Ctx_struct> psr = GraphSyntaxParserNew(tokenStream);  // CParserNew is generated by ANTLR3
		if (!psr) Throw(::Exceptions::BasicLabel("Out of memory trying to allocate parser\n"));

		auto* ast = BuildAST(*psr);

		StructureDescription(std::cout, ast);

		AntlrPtr<struct ANTLR3_COMMON_TREE_NODE_STREAM_struct> nodes = antlr3CommonTreeNodeStreamNewTree(ast, ANTLR3_SIZE_HINT);
		AntlrPtr<struct GraphSyntaxEval_Ctx_struct> evalTree = GraphSyntaxEvalNew(nodes);

		ExceptionContext exceptionContext;
		WorkingGraphSyntaxFile ng;
		evalTree->_userData = &ng;
		evalTree->entrypoint(evalTree);
		if (!exceptionContext._exceptions._errors.empty())
			Throw(ShaderSourceParser::Exceptions::ParsingFailure(MakeIteratorRange(exceptionContext._exceptions._errors)));
		
		GraphSyntaxFile result;
		result._subGraphs.reserve(ng._graphs.size());
		result._imports = ng._imports;
		for (auto& f:ng._graphs)
			result._subGraphs.emplace_back(GraphSyntaxFile::SubGraph{f._name, std::move(f._signature), std::move(f._graph)});
		return result;
    }

///////////////////////////////////////////////////////////////////////////////////////////////////

	class GraphSyntaxSignatureProvider : public BasicSignatureProvider
    {
    public:
        Result FindSignature(StringSection<> name);

        GraphSyntaxSignatureProvider(
			const GraphSyntaxFile& parsedGraphFile,
			const ::Assets::DirectorySearchRules& searchRules);
        ~GraphSyntaxSignatureProvider();
    protected:
		const GraphSyntaxFile* _parsedGraphFile;
    };

	auto GraphSyntaxSignatureProvider::FindSignature(StringSection<> name) -> Result
	{
		// Interpret the given string to find a function signature that matches it
		// First, check to see if it's scoped as an imported function
		auto *scopingOperator = name.begin() + 1;
		while (scopingOperator < name.end()) {
			if (*(scopingOperator-1) == ':' && *scopingOperator == ':')
				break;
			++scopingOperator;
		}
		if (scopingOperator < name.end()) {
			auto import = MakeStringSection(name.begin(), scopingOperator-1).AsString();
			auto functionName = MakeStringSection(scopingOperator+1, name.end());

			auto importedName = _parsedGraphFile->_imports.find(import);
			if (importedName != _parsedGraphFile->_imports.end())
				return BasicSignatureProvider::FindSignature(importedName->second + ":" + functionName.AsString());
			return BasicSignatureProvider::FindSignature(import + ":" + functionName.AsString());
		}

		// Look for the function within the parsed graph syntax file
		auto i = std::find_if(
			_parsedGraphFile->_subGraphs.begin(),
			_parsedGraphFile->_subGraphs.end(),
			[name](const GraphSyntaxFile::SubGraph& g) { return XlEqString(name, g._name); });
		if (i != _parsedGraphFile->_subGraphs.end()) {
			return { i->_name, &i->_signature };
		}

		// Just fallback to default behaviour
		return BasicSignatureProvider::FindSignature(name);
	}

	GraphSyntaxSignatureProvider::GraphSyntaxSignatureProvider(
		const GraphSyntaxFile& parsedGraphFile,
		const ::Assets::DirectorySearchRules& searchRules)
	: BasicSignatureProvider(searchRules)
	, _parsedGraphFile(&parsedGraphFile)
	{}

	GraphSyntaxSignatureProvider::~GraphSyntaxSignatureProvider()
	{}

	std::string ReadGraphSyntax(StringSection<char> input, const ::Assets::DirectorySearchRules& searchRules)
	{
		auto parsedGraph = ParseGraphSyntax(input);

		std::string result;
		// Find each slot implementation in the graph; trim it out, and then
		// build a function.

		auto sigProvider = std::make_unique<GraphSyntaxSignatureProvider>(parsedGraph, searchRules);
		
		for (auto& g:parsedGraph._subGraphs) {
			std::string slotImplementation;
			NodeGraphSignature generatedInterface;
			std::tie(slotImplementation, generatedInterface) = GenerateFunction(g._graph, g._name.c_str(), *sigProvider);
			result += slotImplementation;

			result += GenerateScaffoldFunction(g._signature, generatedInterface, g._name.c_str());
		}

		return result;
	}

	static std::string MakeArchiveName(const IdentifierAndScope& identifierAndScope)
	{
		if (identifierAndScope._scope)
			return ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._scope) + "::" + ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._identifier);
		return ShaderSourceParser::AntlrHelper::AsString<>(identifierAndScope._identifier);
	}

	WorkingGraphSyntaxFile& GetFileContext(const void* ctx) { return *(WorkingGraphSyntaxFile*)((GraphSyntaxEval_Ctx_struct*)ctx)->_userData; }
	WorkingGraphSyntaxFile::Graph& GetGraphContext(const void* ctx) 
	{
		auto& file = GetFileContext(ctx);
		assert(!file._stacks[0].empty());
		unsigned topGraph = file._stacks[0].top();
		return file._graphs[topGraph];
	}

}

extern "C" NodeId Graph_Register(const void* ctx, const char name[], GraphSignatureId signatureId)
{
	auto& f = ShaderPatcher::GetFileContext(ctx);

	assert(signatureId < f._pendingSignatures.size());
	const auto& sig = f._pendingSignatures[signatureId];
	
	NodeId nextGraph = (NodeId)f._graphs.size();
	f._graphs.push_back({std::string(name), {}, sig});
	return nextGraph;
}

extern "C" NodeId RNode_Register(const void* ctx, IdentifierAndScope identifierAndScope)
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);

	NodeId nextId = (NodeId)ng._graph.GetNodes().size();
	ShaderPatcher::Node newNode(ShaderPatcher::MakeArchiveName(identifierAndScope), nextId, ShaderPatcher::Node::Type::Procedure);
	ng._graph.Add(std::move(newNode));
	return nextId;
}

extern "C" NodeId RSlot_Register(const void* ctx, IdentifierAndScope identifierAndScope)
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);

	NodeId nextId = (NodeId)ng._graph.GetNodes().size();
	ShaderPatcher::Node newNode(ShaderPatcher::MakeArchiveName(identifierAndScope), nextId, ShaderPatcher::Node::Type::SlotInput);
	ng._graph.Add(std::move(newNode));
	return nextId;
}

extern "C" ConnectorId Connector_Register(const void* ctx, NodeId node, const char connectorName[])
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	
	ConnectorId nextId = (ConnectorId)ng._connectors.size();
	ng._connectors.push_back({node, connectorName});
	return nextId;
}

extern "C" ConnectorId LiteralConnector_Register(const void* ctx, const char literal[])
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	
	ConnectorId nextId = 0xf0000000u | (ConnectorId)ng._literalConnectors.size();
	ng._literalConnectors.push_back(literal);
	return nextId;
}

extern "C" ConnectionId Connection_Register(const void* ctx, ConnectorId left, ConnectorId right)
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	
	if (left >= ng._connectors.size())
		return ~0u;

	if (right & 0xf0000000u) {
		if ((right & ~0xf0000000u) >= ng._literalConnectors.size())
			return ~0u;

		ShaderPatcher::ConstantConnection connection(
			ng._connectors[left].nodeId, ng._connectors[left]._name,
			ng._literalConnectors[right & ~0xf0000000u]);
		ng._graph.Add(std::move(connection));
	} else {
		if (right >= ng._connectors.size())
			return ~0u;

		if (ng._connectors[right].nodeId == ~0u) {
			auto paramName = ng._connectors[right]._name;

			auto i = std::find_if(
				ng._signature.GetParameters().begin(),
				ng._signature.GetParameters().end(),
				[paramName](const ShaderPatcher::NodeGraphSignature::Parameter& p) { return p._name == paramName; });
			if (i != ng._signature.GetParameters().end()) {
				ShaderPatcher::InputParameterConnection connection(
					ng._connectors[left].nodeId, ng._connectors[left]._name,
					i->_type, i->_name, i->_semantic, i->_default);
				ng._graph.Add(std::move(connection));
			} else {
				ShaderPatcher::InputParameterConnection connection(
					ng._connectors[left].nodeId, ng._connectors[left]._name,
					std::string(), std::string(), std::string(), std::string());
				ng._graph.Add(std::move(connection));
			}
		} else {
			ShaderPatcher::NodeConnection connection(
				ng._connectors[left].nodeId, ng._connectors[right].nodeId,
				ng._connectors[left]._name, ng._connectors[right]._name,
				std::string());
			ng._graph.Add(std::move(connection));
		}
	}

	return ~0u;
}

extern "C" void Node_Name(const void* ctx, NodeId id, const char name[])
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	ng._nodeNameMapping.insert({name, id});
}

extern "C" NodeId Graph_Find(const void* ctx, const char name[])
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	std::string n(name);
	auto i = ng._nodeNameMapping.find(n);
	if (i != ng._nodeNameMapping.end()) return i->second;
	auto si = ng._slotNameMapping.find(n);
	if (si != ng._slotNameMapping.end()) return si->second.first;
	return ~0u;
}

extern "C" NodeId RNode_Find(const void* ctx, const char name[])
{
	auto& ng = ShaderPatcher::GetGraphContext(ctx);
	std::string n(name);
	auto i = ng._nodeNameMapping.find(n);
	if (i != ng._nodeNameMapping.end()) return i->second;
	auto si = ng._slotNameMapping.find(n);
	if (si != ng._slotNameMapping.end()) return si->second.second;
	return ~0u;
}

extern "C" GraphSignatureId GraphSignature_Register(const void* ctx)
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	auto nextId = (unsigned)f._pendingSignatures.size();
	f._pendingSignatures.push_back({});
	return nextId;
}

extern "C" void GraphSignature_ReturnType(const void* ctx, GraphSignatureId sigId, const char returnType[])
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	f._pendingSignatures[sigId].AddParameter({returnType, "result", ShaderPatcher::ParameterDirection::Out});
}

extern "C" void GraphSignature_AddParameter(const void* ctx, GraphSignatureId sigId, const char name[], const char type[])
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	f._pendingSignatures[sigId].AddParameter({type, name});
}

extern "C" void Walk_Push(const void* ctx, unsigned objType, unsigned id)
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	f._stacks[objType].push(id);
}

extern "C" void Walk_Pop(const void* ctx, unsigned objType)
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	assert(!f._stacks[objType].empty());
	f._stacks[objType].pop();
}

extern "C" NodeId Walk_GetActive(const void* ctx, unsigned objType)
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	if (f._stacks[objType].empty())
		return ~0u;
	return f._stacks[objType].top();
}

extern "C" void Import_Register(const void* ctx, const char alias[], const char import[])
{
	auto& f = ShaderPatcher::GetFileContext(ctx);
	assert(f._imports.find(alias) == f._imports.end());
	f._imports.insert(std::make_pair(alias, import));
}
