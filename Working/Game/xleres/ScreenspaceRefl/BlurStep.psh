// Copyright 2015 XLGAMES Inc.
//
// Distributed under the MIT License (See
// accompanying file "LICENSE" or the website
// http://www.opensource.org/licenses/mit-license.php)

#include "../TextureAlgorithm.h"

Texture2D<float4>	InputTexture;

// static const float FixedWeights[] = { 0.05f, 0.05f, 0.1f, 1.f, 0.1f, 0.05f, 0.05f };

cbuffer Constants
{
	float4	FilteringWeights0;		// weights for gaussian filter
	float3	FilteringWeights1;
}

float4 HorizontalBlur(float4 position : SV_Position, float2 texCoord : TEXCOORD0) : SV_Target0
{
		//
		//	Blur out the final reflection texture
		//	Try to fill in some of the spaces that are
		//		generated by jittering.
		//

	const int offset[] = { -3, -2, -1, 0, 1, 2, 3 };
	const uint sampleCount = 7;

	float FixedWeights[7];
	FixedWeights[0] = FilteringWeights0.x;
	FixedWeights[1] = FilteringWeights0.y;
	FixedWeights[2] = FilteringWeights0.z;
	FixedWeights[3] = FilteringWeights0.w;
	FixedWeights[4] = FilteringWeights1.x;
	FixedWeights[5] = FilteringWeights1.y;
	FixedWeights[6] = FilteringWeights1.z;

	float totalWeight = 0.f;
	float totalFixedWeights = 0.f;
	float4 result = 0.0.xxxx;
	float accumAlpha = 0.f;
	[unroll] for (uint c=0; c<sampleCount; c++) {
		uint2 pixelCoord = uint2(position.xy);
		float4 texSample = LoadFloat4(InputTexture, pixelCoord + int2(offset[c], 0), 0);
		float weight = texSample.a * FixedWeights[c];
		totalWeight += weight;
		result.rgba += texSample.rgba * weight;

		totalFixedWeights += FixedWeights[c];
		accumAlpha += texSample.a * FixedWeights[c];
	}

	if (totalWeight > 0.0001f && totalFixedWeights > 0.0001f) {
		result.rgb /= totalWeight;
		result.a = accumAlpha / totalFixedWeights;
	} else {
		result.rgba = 0.0.xxxx;
	}
	return result;
}

float4 VerticalBlur(float4 position : SV_Position, float2 texCoord : TEXCOORD0) : SV_Target0
{
		//
		//	Blur out the final reflection texture
		//	Try to fill in some of the spaces that are
		//		generated by jittering.
		//

	const int offset[] = { -3, -2, -1, 0, 1, 2, 3 };
	const uint sampleCount = 7;

	float FixedWeights[7];
	FixedWeights[0] = FilteringWeights0.x;
	FixedWeights[1] = FilteringWeights0.y;
	FixedWeights[2] = FilteringWeights0.z;
	FixedWeights[3] = FilteringWeights0.w;
	FixedWeights[4] = FilteringWeights1.x;
	FixedWeights[5] = FilteringWeights1.y;
	FixedWeights[6] = FilteringWeights1.z;

	float totalWeight = 0.f;
	float totalFixedWeights = 0.f;
	float4 result = 0.0.xxxx;
	float accumAlpha = 0.f;
	[unroll] for (uint c=0; c<sampleCount; c++) {
		uint2 pixelCoord = uint2(position.xy);
		float4 texSample = LoadFloat4(InputTexture, pixelCoord + int2(0, offset[c]), 0);
		float weight = texSample.a * FixedWeights[c];
		totalWeight += weight;
		result.rgba += texSample.rgba * weight;

		totalFixedWeights += FixedWeights[c];
		accumAlpha += texSample.a * FixedWeights[c];
	}

	if (totalWeight > 0.0001f && totalFixedWeights > 0.0001f) {
		result.rgb /= totalWeight;
		result.a = accumAlpha / totalFixedWeights;
	} else {
		result.rgba = 0.0.xxxx;
	}
	return result;
}
